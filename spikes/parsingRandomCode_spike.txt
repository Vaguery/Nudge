randomly generated 100-point program:

block {
  channel x
  instr int_multiply
  erc int, 0
  instr int_multiply
  erc int, 4
  instr int_divide
  instr int_multiply
  instr int_multiply
  instr int_multiply
  channel x
  channel x
  channel x
  instr int_multiply
  instr int_multiply
  channel x
  erc int, 0
  instr int_add
  channel x
  instr int_multiply
  channel x
  erc int, 0
  instr int_multiply
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_add
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  instr int_divide
  instr int_divide
  instr int_divide
  instr int_multiply
  instr int_add
  instr int_multiply
  channel x
  erc int, 4
  channel x
  instr int_multiply
  instr int_divide
  instr int_multiply
  instr int_multiply
  instr int_multiply
  erc int, 0
  erc int, 4
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_multiply
  instr int_multiply
  erc int, 4
  instr int_multiply
  channel x
  channel x
  instr int_multiply
  instr int_multiply
  channel x
  instr int_multiply
  erc int, 4
  channel x
  channel x
  instr int_multiply
  channel x
  instr int_divide
  channel x
  erc int, 0
  channel x
  channel x
  instr int_add
  channel x
  erc int, 4
  channel x
  instr int_divide
  instr int_multiply
  instr int_divide
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_multiply
  erc int, 4
  instr int_add
  instr int_multiply
  erc int, 4
  channel x
  instr int_add
  channel x
  instr int_multiply
  channel x
  erc int, 4
  instr int_multiply
  erc int, 4
  erc int, 4
  instr int_multiply
  instr int_multiply}

results of running it:

channel x assignment, top value on INT stack at end of run | [entire INT stack at end of run]
-20, -1280  |  0,16,320,-1280,
-19, -1216  |  0,16,285,-1216,
-18, -1152  |  0,16,252,-1152,
-17, -1088  |  0,16,221,-1088,
-16, -1024  |  0,16,192,-1024,
-15, -960  |  0,16,165,-960,
-14, -896  |  0,16,140,-896,
-13, -832  |  0,16,117,-832,
-12, -768  |  0,16,96,-768,
-11, -704  |  0,16,77,-704,
-10, -640  |  0,16,60,-640,
-9, -576  |  0,16,45,-576,
-8, -512  |  0,16,32,-512,
-7, -448  |  0,16,21,-448,
-6, -384  |  0,16,12,-384,
-5, -320  |  0,16,5,-320,
-4, -256  |  0,16,0,-256,
-3, -192  |  0,16,-3,-192,
-2, -128  |  0,16,-4,-128,
-1, -64  |  0,16,-3,-64,
0, 0  |  4,0,0,
1, 64  |  0,16,5,64,
2, 128  |  0,16,12,128,
3, 192  |  0,16,21,192,
4, 256  |  0,16,32,256,
5, 320  |  0,45,320,
6, 384  |  0,60,384,
7, 448  |  0,77,448,
8, 512  |  0,96,512,
9, 576  |  0,117,576,
10, 640  |  0,140,640,
11, 704  |  0,165,704,
12, 768  |  0,192,768,
13, 832  |  0,221,832,
14, 896  |  0,252,896,
15, 960  |  0,285,960,
16, 1024  |  0,320,1024,
17, 1088  |  0,357,1088,
18, 1152  |  0,396,1152,
19, 1216  |  0,437,1216,
20, 1280  |  0,480,1280,


ATTEMPT at hand-parsing the RPN code that generates the three or four output numbers

first part:

block {
  channel x
  instr int_multiply
  erc int, 0
  instr int_multiply
  erc int, 4
  instr int_divide
  instr int_multiply
  instr int_multiply
  instr int_multiply
  channel x
  channel x
  channel x
  instr int_multiply
  instr int_multiply
  channel x
  erc int, 0
  instr int_add
  channel x
  instr int_multiply
  channel x
  erc int, 0
  instr int_multiply
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_add
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  instr int_divide
  instr int_divide
  instr int_divide
  instr int_multiply
  instr int_add
  instr int_multiply
  channel x
  erc int, 4
  channel x
  instr int_multiply
  instr int_divide
  instr int_multiply
  instr int_multiply
  instr int_multiply
  erc int, 0
  erc int, 4
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_multiply
  instr int_multiply
  erc int, 4
  instr int_multiply
  channel x
  channel x
  instr int_multiply
  instr int_multiply
  channel x
  instr int_multiply

This one seems to fail due to insufficient params... sometimes:

((((*(((*(*((*(+(*(÷(÷(÷(*(((*(*(*((( *x)*0)÷4))))*(((x*(x*x))*((((x+0)*x)*(x*0))*4))+0))*4))))))))*(x÷(4*x)))))*(0*4))*0))*4)*(x*x))*x)


second one:
  erc int, 4
  channel x
  channel x
  instr int_multiply
  channel x
  instr int_divide
  channel x
  erc int, 0
  channel x
  channel x
  instr int_add
  channel x
  erc int, 4
  channel x
  instr int_divide
  instr int_multiply
  instr int_divide
  instr int_multiply
  erc int, 4
  instr int_multiply
  instr int_multiply
  instr int_multiply
  erc int, 0
  instr int_multiply
  erc int, 4
  instr int_add
  instr int_multiply

y = (4*(((((x*x)÷x)*(x*((0*((x+x)÷(x*(4÷x))))*4)))*0)+4))
                 ^ will fail when x = 0 ^
    Basically this will reach back into the preceding results to get more stuff IF x = 0
    
Essentially any ÷ results in a conditional when DIV0 errors happen.
    
third one:
  erc int, 4
  channel x
  instr int_add
  channel x
  instr int_multiply

y = ((4+x)*x)
  = x^2 + 4x

fourth one:
  channel x
  erc int, 4
  instr int_multiply
  erc int, 4
  erc int, 4
  instr int_multiply
  instr int_multiply}

y = ((x*4)*(4*4))
  = 64 * x
